// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Admin {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())

  blogPosts     BlogPost[]
  createdQuotes Quote[]    @relation("AdminCreatedQuotes")
}

model Service {
  id          String   @id @default(uuid())
  title       String   @unique
  description String?
  department  String? // "Environmental", "HSE", "Engineering", etc
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  bookings Booking[]
}

model TeamMember {
  id          String  @id @default(uuid())
  name        String
  title       String
  credentials String?
  bio         String?
  imageUrl    String?
  order       Int     @default(0)
  isActive    Boolean @default(true)

  // Staff/Consultant fields
  email        String? @unique
  passwordHash String?
  role         String  @default("PUBLIC") // "PUBLIC", "STAFF"
  isPublic     Boolean @default(true) // Show on website "Our Team" page

  // Services assigned to this staff member
  assignedServices String[] // Array of service IDs this staff manages

  // Relations - assigned bookings
  assignedBookings Booking[]

  // Quotes created by this consultant/admin
  createdQuotes Quote[] @relation("CreatedQuotes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Booking {
  id          String        @id @default(uuid())
  clientName  String
  clientEmail String
  clientPhone String?
  message     String?
  status      BookingStatus @default(NEW)
  bookingRef  String        @unique // Unique reference for client lookup

  // Consultant assignment
  assignedConsultantId String?
  assignedConsultant   TeamMember? @relation(fields: [assignedConsultantId], references: [id])

  // Service reference
  serviceId String
  service   Service @relation(fields: [serviceId], references: [id])

  // Quote and Invoice
  quote   Quote?
  invoice Invoice?

  // Tracking
  consultantNotifiedAt   DateTime? // When consultant was emailed
  consultantRepliedAt    DateTime? // When consultant first reached out
  clientConfirmEmailSent DateTime? // When confirmation email was sent to client
  lastContactMethod      String? // How we last contacted client: "WHATSAPP", "EMAIL", "PHONE"

  // Internal notes for staff/admin
  internalNotes String? // Activity log: "Consultant reached out on 13-Feb-2026", "Quote sent: $5000", etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GalleryImage {
  id          String   @id @default(uuid())
  category    String // "projects", "worksite", "services"
  title       String?
  description String?
  imageUrl    String // Path to the image file
  order       Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum BookingStatus {
  NEW // Just received, awaiting admin assignment
  ASSIGNED // Consultant assigned and notified
  AWAITING_CLIENT // Consultant has reached out, waiting for client response
  COMPLETED // Project completed or closed
}

enum QuoteStatus {
  DRAFT // Quote being prepared
  SENT // Quote sent to client
  VIEWED // Client has opened/viewed quote
  APPROVED // Client approved the quote
  REJECTED // Client rejected the quote
  NEGOTIATING // Client sent counter-offer or questions
}

enum InvoiceStatus {
  GENERATED // Invoice created
  SENT // Invoice sent to client
  PAID // Payment confirmed
  OVERDUE // Payment due date passed
  CANCELLED // Invoice cancelled
}

enum DeliveryMethod {
  EMAIL
  WHATSAPP
  SECURE_LINK
}

model Quote {
  id        String @id @default(uuid())
  bookingId String @unique

  // Created by consultant or admin (one must be set)
  createdById String?
  createdBy   TeamMember? @relation("CreatedQuotes", fields: [createdById], references: [id])

  adminCreatedById String?
  adminCreatedBy   Admin?  @relation("AdminCreatedQuotes", fields: [adminCreatedById], references: [id])

  // Quote details
  lineItems     LineItem[]
  totalAmount   Float
  notes         String? // Notes visible to client
  internalNotes String? // Admin only notes

  // Delivery tracking
  deliveryMethod  DeliveryMethod?
  deliveryTime    DateTime?
  deliveryMethods DeliveryMethod[] @default([]) // Track all methods used to send this quote

  // Client response tracking
  clientResponse String? // "EMAIL_REPLY", "WHATSAPP_REPLY", "PORTAL_APPROVAL", "PORTAL_REJECTION"
  clientMessage  String? // Any message from client about the quote
  responseTime   DateTime?

  // Status
  status QuoteStatus @default(DRAFT)

  // Agreement signing
  agreedAt     DateTime?
  signedPdfUrl String? // URL to client uploaded signed PDF
  verifiedAt   DateTime? // When admin verified the signed document
  verifiedById String? // Admin who verified
  isLocked     Boolean   @default(false) // Locked after client signs

  // Relations
  booking Booking  @relation(fields: [bookingId], references: [id])
  invoice Invoice?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LineItem {
  id      String @id @default(uuid())
  quoteId String

  description String // "Site inspection", "Lab analysis", etc
  quantity    Float  @default(1)
  unitPrice   Float
  total       Float // quantity * unitPrice

  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

model Invoice {
  id        String @id @default(uuid())
  quoteId   String @unique
  bookingId String @unique

  // Payment details
  totalAmount      Float
  bankAccount      String // "GTBANK" or "UBA"
  accountName      String?
  accountNumber    String?
  paymentReference String?

  // Status
  status  InvoiceStatus @default(GENERATED)
  sentAt  DateTime?
  dueDate DateTime
  paidAt  DateTime?

  // Relations
  quote         Quote          @relation(fields: [quoteId], references: [id])
  booking       Booking        @relation(fields: [bookingId], references: [id])
  paymentProofs PaymentProof[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PaymentProof {
  id        String @id @default(uuid())
  invoiceId String

  // File/receipt details
  proofUrl   String // URL to bank transfer receipt/proof
  uploadedAt DateTime @default(now())

  // Verification
  verifiedAt        DateTime?
  verifiedById      String? // Admin who verified
  verificationNotes String?

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

enum BlogPostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model BlogCategory {
  id          String  @id @default(uuid())
  name        String  @unique
  slug        String  @unique
  description String?
  order       Int     @default(0)
  isActive    Boolean @default(true)

  posts BlogPost[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model BlogPost {
  id               String  @id @default(uuid())
  title            String
  slug             String  @unique
  excerpt          String // Short summary for listings
  content          String // Full HTML content
  featuredImageUrl String?

  // Category and tags
  categoryId String
  category   BlogCategory @relation(fields: [categoryId], references: [id])
  tags       String[] // Array of tag strings: ["environmental", "compliance", "sustainability"]

  // Author (Admin who wrote it)
  authorId String
  author   Admin  @relation(fields: [authorId], references: [id])

  // Publishing
  status      BlogPostStatus @default(DRAFT)
  publishedAt DateTime?

  // SEO
  metaDescription String?

  // Stats
  viewCount Int @default(0)

  // Comments
  comments BlogComment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model BlogComment {
  id     String   @id @default(uuid())
  postId String
  post   BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Commenter info
  authorName  String
  authorEmail String

  // Content
  content String

  // Moderation
  isApproved Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
